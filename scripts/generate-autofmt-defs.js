#!/usr/bin/env node
// @ts-check
/// <reference types="node" />
// Generate elisp-autofmt definition stubs from packages.
// Uses elisp-autofmt's --gen-defs to extract definitions, then converts to elisp.
//
// Usage: node generate-autofmt-defs.js <output.el> <package> [package ...]

const { execSync } = require("child_process");
const { readdirSync, writeFileSync } = require("fs");
const { basename, join } = require("path");

/**
 * Simple glob supporting single-star wildcards in path segments.
 * @param {string} pattern - e.g. ".eask/star/elpa/pkg-star/pkg.el" (star = *)
 * @returns {string[]}
 */
function findFiles(pattern) {
  const parts = pattern.split("/");
  /** @type {string[]} */
  let paths = [""];
  for (const part of parts) {
    /** @type {string[]} */
    const next = [];
    for (const p of paths) {
      if (part === "*") {
        try {
          for (const entry of readdirSync(p || ".")) {
            next.push(join(p, entry));
          }
        } catch {
          // Directory doesn't exist.
        }
      } else if (part.includes("*")) {
        const [prefix, suffix] = part.split("*");
        try {
          for (const entry of readdirSync(p || ".")) {
            if (entry.startsWith(prefix) && entry.endsWith(suffix)) {
              next.push(join(p, entry));
            }
          }
        } catch {
          // Directory doesn't exist.
        }
      } else {
        next.push(join(p, part));
      }
    }
    paths = next;
  }
  return paths;
}

const outputFile = process.argv[2];
const packages = process.argv.slice(3);

if (!outputFile || !packages.length) {
  console.error("Usage: node generate-autofmt-defs.js <output.el> <package> [package ...]");
  process.exit(1);
}

// Find elisp-autofmt.py.
const autofmtPy = findFiles(".eask/*/elpa/elisp-autofmt-*/elisp-autofmt.py")[0];
if (!autofmtPy) {
  console.error("Error: elisp-autofmt.py not found. Run 'npm install' first.");
  process.exit(1);
}

// Find input files for each package.
/** @type {string[]} */
const inputFiles = [];
for (const pkg of packages) {
  const matches = findFiles(`.eask/*/elpa/${pkg}-*/${pkg}.el`);
  if (matches.length) {
    inputFiles.push(matches[0]);
  } else {
    console.warn(`Warning: No .el file found for package '${pkg}'`);
  }
}

if (!inputFiles.length) {
  console.error("Error: No input files found.");
  process.exit(1);
}

/**
 * @typedef {[string, number | string, number | string, { indent?: number | string } | null]} FnDef
 * @type {Record<string, FnDef>}
 */
const allDefs = {};
for (const inputFile of inputFiles) {
  const json = execSync(`python3 "${autofmtPy}" --gen-defs "${inputFile}" /dev/stdout`, {
    encoding: "utf-8",
    stdio: ["pipe", "pipe", "ignore"],
  });
  /** @type {{ functions: Record<string, FnDef> }} */
  const parsed = JSON.parse(json);
  Object.assign(allDefs, parsed.functions);
}

// Generate elisp output.
const outBase = basename(outputFile);
const feature = basename(outputFile, ".el");
const lines = [
  `;;; ${outBase} --- Auto-generated elisp-autofmt definitions. -*- lexical-binding: t -*-`,
  "",
  ";;; Commentary:",
  `;; Macro definitions extracted from: ${packages.join(", ")}.`,
  `;; This is used to provide formatting info to elisp-autofmt even if ${packages.length == 1 ? "this package is" : "these packages are"} not installed locally.`,
  ";; Auto-generated by scripts/generate-autofmt-defs.js - do not edit manually.",
  "",
  ";;; Code:",
  "",
];

const macros = Object.entries(allDefs)
  .filter(([, val]) => val[0] === "macro" && val[3]?.indent !== undefined)
  .sort(([a], [b]) => a.localeCompare(b));

for (const [name, val] of macros) {
  const indent = JSON.stringify(val[3]?.indent);
  lines.push(`(defmacro ${name} (&rest _)`);
  lines.push(`  (declare (indent ${indent})))`);
  lines.push("");
}

lines.push(`(provide '${feature})`);
lines.push(`;;; ${outBase} ends here`);

writeFileSync(outputFile, lines.join("\n") + "\n");
console.log(`Wrote ${macros.length} macro definitions to ${outputFile}`);
